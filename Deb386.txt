
 1. About Deb386

 Deb386 is a ring 0 debugger. It's using DebugR.bin, a variant of Debug/X,
 as the debugger core. There are two variants of Deb386 supplied, Deb386.exe
 and Deb386w.exe; the first is supposed to work with HDPMI only, while the
 latter should run with any privileged code. 


 2. Usage
 
 Deb386 is a DOS TSR, to install it run "deb386 -i". Once installed, it will
 become active as soon as a ring0-debugger-aware version of HDPMI is launched.
 This is important, so in other words: the debugger must be initialized by a
 program running in ring0 protected-mode, before it can do anything. After this
 step the debugger prompt will appear if an exception has been detected.

 Deb386 itself understands the following cmdline options:

   -i   install
   -b   stop at init
   -n   make debugger invisible to Int 41h
   -u   uninstall

 Deb386w additionally accepts:

   -c:n COM port to use ( if AUXIN/AUXOUT is active )
   -2   displays on secondary monitor ( if KBDIN/VIOOUT is active )

 Anything behind option -i will be passed to the debugger core DebugR.


 3. Details

 3.1 Both Deb386 and Deb386w

 - The debugger uses the interrupt 68h real-mode API for ring0-debugger
   detection and initialization ( the same API is used by MS WDEB386 and
   386SWAT ). It stays in conventional memory and so doesn't has to fiddle
   with paging so far as the ring0 host "identity-maps" this part of memory.
    Note that if WDEB386 or 386SWAT are running, Deb386 will detect that and
   not install itself.

 - The exceptions that may wake up the debugger are 0, 1, 3, 6, 0Dh and 0Eh,
   in protected-mode only. No other events are handled. The debugger core
   DebugR does ignore all exceptions coming from v86-mode. So it's not possible
   to debug DOS "real-mode" applications with Deb386.

 - As default, Deb386 is visible to protected-mode Int 41h. So it will be
   detected by protected-mode programs, including the HX program loaders
   ( which will then emit a breakpoint at program start ). If this is to be
   avoided, add the /n option.

 - Deb386 doesn't use the 80386+ debug registers; to set a breakpoint it
   has to write an int3 instruction. If the memory page is readonly and the
   CR0 WP bit is set, a page fault will occur. To avoid this error, one has
   to clear the WP bit before the debug session; see tool ResWP.exe.

 - If the DPMI host runs clients with IOPL 0 ( there exists HDPMI variants that
   do that ), the clients will trigger an exception 0Dh if instructions CLI/STI
   or IN/INS/OUT/OUTS for trapped ports are executed. The debugger core DebugR
   does ignore such exceptions.

 - The debugger core DebugR has absolutely no knowledge about Windows or DOS
   peculiarities. So, for example, it cannot distinguish "invalid page faults"
   and "valid" ones.

 3.2 Deb386

 - As default, Deb386 uses the mode switching routines of HDPMI for its input
   and output. The debugger will most likely crash if there's an error in those
   routines.

 - HDPMI ring0 code runs with interrupts disabled. There may be some places
   that are untraceable, assuming that the code isn't interrupted. Also,
   mode-switching code cannot be single-stepped - so stop single-stepping
   if instructions like LIDT or LTR appear in the disassembly.

 - When uninstalling, there's no proper way for Deb386 to detect if a DPMI
   host is still installed, with a IDT that has been modified by Deb386. So
   always first uninstall the DPMI host, then Deb386.

 - Using option /b the debugger will stop while HDPMI is still located in
   conventional memory.

 3.3 Deb386w

 - Deb386w does NOT do mode switches. This makes it more generic, but requires
   to handle I/O on a rather low level. There are currently two possibilities:
   either do the I/O through a serial line or using low-level video/keyboard
   code:

   a) I/O through a serial connection (COMx). This requires to assemble Deb386w
     with options -DAUXOUT=1 and -DAUXIN=1 ( see Makefile for details ). The
     default for the COM port is COM1, may be changed with option /C.

     As an example, if DOS is running in the Qemu emulator, one may connect the
     emulated COM port to the terminal, using Qemu cmdline options:

    -chardev stdio,id=char0,logfile=serial.log,signal=off -serial chardev:char0

   b) I/O through low-level video/keyboard code. This requires to assemble
     Deb386w with options -DVIOOUT=1 and -DKBDIN=1. The output may be directed
     to a secondary ( monochrome ) adapter with cmdline option /2. The input
     is a slight problem, since key translations have to be done by the
     debugger; there exist 2 translation tables, for US or GR keyboards, default
     is GR ( see below how to set US ).

 - Since Deb386w uses the same interface than WDEB386 does, it might be used as
   a ( rather restricted ) Win3x/Win9x kernel debugger. In any case, you'll
   have to feed DebugR with the -m option to make it assume that the master PIC
   vectors don't overlap with exception vectors.


 4, Requirements to create the Binaries

   - JWasm.
   - DebugR - this Debug/X variant is included as a binary.
   - if debug displays are to be activated, JWasm v2.17+ is needed.
   - make utility.

   "nmake aux=1" will create Deb386w.exe with AUXIN/AUXOUT enabled.
   "nmake kbd=us" will create Deb386w.exe with US kbd layout support.


 5. License

 Deb386 is released under the MIT license. See license.txt for details.

 Andreas Grech
